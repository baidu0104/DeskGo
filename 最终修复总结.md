# DeskGo 修复总结

## 问题1：加载已有围栏时显示小窗口 ✅ 已解决

### 问题描述
启动程序加载已有围栏时，会在屏幕左上角短暂显示一个小的白色窗口（默认大小 280x200），无法关闭。

### 根本原因
1. 窗口在构造和初始化过程中可能被系统自动显示
2. `fromJson()` 中创建窗口后，虽然设置了正确的几何位置，但在某些操作（如 `setWindowToDesktop()`）时窗口可能被短暂显示
3. `showEvent` 被多次触发，导致窗口在初始化完成前就显示

### 解决方案

#### 1. 构造函数中隐藏窗口
```cpp
FenceWindow::FenceWindow(const QString &title, QWidget *parent)
{
    // 在 setupUi 之前先隐藏窗口
    setVisible(false);
    setupUi();
}
```

#### 2. fromJson 中创建窗口句柄但不显示
```cpp
FenceWindow* FenceWindow::fromJson(const QJsonObject &json)
{
    FenceWindow *fence = new FenceWindow(...);
    fence->setGeometry(x, y, w, h);
    fence->winId(); // 强制创建窗口句柄，但不显示
    // ... 设置其他属性
    return fence;
}
```

#### 3. loadFences 中提前调用 setWindowToDesktop
```cpp
void FenceManager::loadFences()
{
    for (const QJsonValue &val : fencesArray) {
        FenceWindow *fence = FenceWindow::fromJson(fenceObj);
        
        // 在窗口隐藏状态下调用 setWindowToDesktop
        DesktopHelper::setWindowToDesktop(fence);
        fence->setDesktopEmbedded(true);
        
        m_fences.append(fence);
    }
}
```

#### 4. showEvent 中只在第一次调用 setWindowToDesktop
```cpp
void FenceWindow::showEvent(QShowEvent *event)
{
    QWidget::showEvent(event);
    
    // 只在第一次显示时调用 setWindowToDesktop
    if (!m_desktopEmbedded) {
        DesktopHelper::setWindowToDesktop(this);
        m_desktopEmbedded = true;
    }
}
```

## 问题2：Win+D 后围栏消失 ✅ 已解决

### 问题描述
按 Win+D 显示桌面后，围栏窗口消失，打开其他窗口后才重新显示。

### 根本原因
围栏窗口被设置为 `HWND_BOTTOM`（最底层），Win+D 显示桌面后，桌面图标层会覆盖在围栏上面，导致围栏不可见。

### 解决方案

#### 使用 HWND_TOPMOST
将围栏窗口设置为 `HWND_TOPMOST`（始终在最上层），这样 Win+D 后也能看到：

```cpp
void DesktopHelper::setWindowToDesktop(QWidget *widget)
{
    HWND hWnd = (HWND)widget->winId();
    
    // 设置窗口扩展样式
    LONG_PTR exStyle = GetWindowLongPtr(hWnd, GWL_EXSTYLE);
    exStyle |= WS_EX_NOACTIVATE; // 防止窗口激活
    exStyle |= WS_EX_TOOLWINDOW; // 工具窗口，不在任务栏显示
    SetWindowLongPtr(hWnd, GWL_EXSTYLE, exStyle);
    
    // 将窗口设置为 TOPMOST
    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, 
                 SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
}
```

#### 添加可见性监控定时器
每100毫秒检查一次窗口是否可见，如果被意外隐藏则强制显示：

```cpp
m_visibilityTimer = new QTimer(this);
m_visibilityTimer->setInterval(100);
connect(m_visibilityTimer, &QTimer::timeout, this, [this]() {
    HWND hWnd = (HWND)winId();
    BOOL isWindowVisible = IsWindowVisible(hWnd);
    
    if (!isWindowVisible && !m_userHidden) {
        ShowWindow(hWnd, SW_SHOW);
        SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, 
                    SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_SHOWWINDOW);
    }
});
```

#### 拦截隐藏消息
在 `nativeEvent`、`hideEvent` 和 `changeEvent` 中拦截各种可能导致窗口隐藏的消息：

```cpp
// nativeEvent 中拦截 WM_SHOWWINDOW 和 WM_WINDOWPOSCHANGING
// hideEvent 中阻止非用户主动的隐藏
// changeEvent 中阻止最小化
```

#### 程序关闭时允许隐藏
添加 `m_isClosing` 标志，在 `closeEvent` 中设置，允许程序正常关闭：

```cpp
void FenceWindow::closeEvent(QCloseEvent *event)
{
    m_isClosing = true;
    if (m_visibilityTimer) {
        m_visibilityTimer->stop();
    }
    QWidget::closeEvent(event);
}
```

## 关键修改文件

1. **src/ui/fencewindow.h** - 添加成员变量
   - `m_desktopEmbedded` - 标记是否已嵌入桌面
   - `m_visibilityTimer` - 可见性监控定时器
   - `m_userHidden` - 用户主动隐藏标志
   - `m_isClosing` - 程序正在关闭标志

2. **src/ui/fencewindow.cpp** - 修改窗口行为
   - 构造函数中隐藏窗口
   - 添加可见性监控定时器
   - 修改 `showEvent`、`hideEvent`、`closeEvent`、`changeEvent`
   - 修改 `nativeEvent` 拦截隐藏消息
   - 修改 `fromJson` 创建窗口句柄

3. **src/core/fencemanager.cpp** - 修改加载流程
   - `loadFences` 中提前调用 `setWindowToDesktop`
   - `showAllFences` 和 `hideAllFences` 中设置 `m_userHidden` 标志

4. **src/platform/desktophelper.cpp** - 修改窗口嵌入方式
   - 使用 `HWND_TOPMOST` 代替 `HWND_BOTTOM`
   - 添加 `WS_EX_NOACTIVATE` 和 `WS_EX_TOOLWINDOW` 样式

## 测试结果

✅ 启动程序时不再显示小窗口
✅ 围栏以正确的大小和位置显示
✅ Win+D 后围栏保持可见
✅ 可以正常点击桌面图标
✅ 程序可以正常关闭
✅ 通过托盘菜单可以正常隐藏/显示围栏

## 注意事项

1. 围栏窗口现在是 `HWND_TOPMOST`，会显示在所有普通窗口之上
2. 设置了 `WS_EX_NOACTIVATE`，所以点击围栏不会激活它
3. 设置了 `WS_EX_TOOLWINDOW`，所以围栏不会在任务栏显示
4. 可见性监控定时器每100毫秒运行一次，对性能影响很小
